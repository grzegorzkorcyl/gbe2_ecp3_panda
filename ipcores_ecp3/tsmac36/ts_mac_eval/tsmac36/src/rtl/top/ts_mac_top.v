// ===========================================================================
// Verilog module generated by IPexpress
// Filename: ts_mac_top.v
// Copyright 2005 (c) Lattice Semiconductor Corporation. All rights reserved.
// ===========================================================================
//

`timescale 1 ns/ 1ns
module ts_mac_top (

    // clock, clock enables and reset
    gtx_clk,
    tx_clk,

    txmac_clk_en,
    rxmac_clk_en,

    sys_clk,
    hclk,
    rx_clk,
    rxmac_clk,
    txmac_clk,
    reset_n,

    // Input signals to the GMII
    rx_dv,
    rx_er,
    rxd,
    col,
    crs,

    // orcastra interface
    pc_clk,
    pc_datain,
    pc_ready,
    pc_dataout,
    pc_error,
    pc_retry,
    pc_ack,
    jtag_present,
    jtag_parallel,
    // JTAG Port
    tdi,
    tck,
    tms,
    tdo,

    // Output signals from the MII Management Interface

    // Output signals from the GMII
    tx_en,
    tx_er,
    txd,

    // These are test points on the evaluation board
    tx_fifodata,
    tx_fifoavail,
    tx_fifoeof,
    tx_fifoempty,
    tx_sndpausreq,
    tx_fifoctrl,
    tx_fifo_full_ri,
    tx_macread,
    tx_discfrm,
    tx_staten,
    tx_done,
    gbit_en,
    phy_reset_n
);

// ---------------- clock, clock enables and reset inputs -----------------
output                gtx_clk;            // Gigabit Transmit clock
output                rxmac_clk;          // Rx_clock out to App I/F
output                txmac_clk;          // Tx_clock out to App I/F
input                 tx_clk;             // Transmit clock

input                 txmac_clk_en;
input                 rxmac_clk_en;


input                 sys_clk;            // system clock
input                 rx_clk;             // Receive clock
input                 reset_n;            // Global reset

// ----------------------- Input signals to the GMII -------------------
input  [7:0]          rxd  /* synthesis syn_useioff=0 */;  // Receive data
input                 rx_dv/* synthesis syn_useioff=0 */;  // Receive data valid
input                 rx_er/* synthesis syn_useioff=0 */;  // Receive data error

input                 col;                                 // Collision detect
input                 crs;                                 // Carrier Sense
// ------------------ Input/ouputs signals to the Orcastra Interface ----
input                 pc_clk;
input                 pc_datain;
input                 pc_ready;
output                pc_dataout;
output                pc_error;
output                pc_retry;
output                pc_ack;
output                jtag_present;
input                 jtag_parallel;
// ------------------ Input/output signals to the JTAG Port --------------
input                 tdi;
input                 tck;
input                 tms;
output                tdo;

// -------------------- Output signals from the GMII -----------------------
output [7:0]          txd;                // Transmit data
output                tx_en;              // Transmit Enable
output                tx_er;              // Transmit Error

// These are test points on the evaluation board
output [7:0]          tx_fifodata;
output                tx_fifoavail;
output                tx_fifoeof;
output                tx_fifoempty;
output                tx_sndpausreq;
output                tx_fifoctrl;
output                tx_fifo_full_ri;
output                tx_macread;
output                tx_discfrm;
output                tx_staten;
output                tx_done;
output                gbit_en;

// -------------------- Input signals to the CPU I/F -------------------
input                 hclk;        // Clock

// -------------------- Input/Output signals from the MII I/F ----------------

// -------------------- Misc Output signals to be used with eval board only --
output                phy_reset_n;  // used to reset PHY device
parameter pdevice_family = "ECP3";
//////////////////////////////////////////////////////////////////////////////
// Internal wires related to fifo client interfaces and host bus interface
//////////////////////////////////////////////////////////////////////////////

// -------------------- Input signals to the CPU I/F -------------------
wire  [7:0]                     haddr;              // Address Bus
wire  [7:0]                     hdatain;            // Input data Bus
wire                            hcs_n;              // Chip select
wire                            hwrite_n;           // Register write
wire                            hread_n;            // Register read

// -------------------- Output signals from the CPU I/F -------------------
wire [7:0]                      hdataout;           // Output data Bus
wire                            hdataout_en_n;      // Data Out Enable
wire                            hready_n;           // Ready signal

// ---------------- Input signals to the Tx MAC FIFO I/F ---------------
wire  [7:0]                     tx_fifodata;        // Data Input from FIFO
wire                            tx_fifoavail;       // Data Available in FIFO
wire                            tx_fifoeof;         // End of Frame
wire                            tx_fifoempty;       // FIFO Empty
wire  [15:0]                    tx_sndpaustim;      // Pause frame parameter
wire                            tx_sndpausreq;      // Transmit PAUSE frame
wire                            tx_fifoctrl;        // Control frame or Not

// ---------------- Input signals to the Rx MAC FIFO I/F ---------------
wire                            rx_fifo_full;       // Receive FIFO Full
wire                            ignore_pkt;         // Ignore the frame

// ---------------- Output signals from the Tx MAC FIFO I/F ---------------
wire                            tx_macread;         // Read FIFO
wire                            tx_discfrm;         // Discard Frame
wire                            tx_staten;          // Status Vector Valid
wire                            tx_done;            // Transmit of Frame done
wire [30:0]                     tx_statvec;         // Tx Status Vector

// ---------------- Output signals from the Rx MAC FIFO I/F ---------------
wire                            rx_fifo_error;      // FIFO full detected
wire [31:0]                     rx_stat_vector;     // Rx Status Vector
wire [7:0]                      rx_dbout;           // Data Output to FIFO
wire                            rx_write;           // Write FIFO
wire                            rx_stat_en;         // Status Vector Valid
wire                            rx_eof;             // Entire frame written
wire                            rx_error;           // Erroneous frame

wire                           rx_write_e;         // Write FIFO conditioned with rx enable
wire                           tx_macread_e;       // Read FIFO conditioned with tx enable
//////////////////////////////////////////////////////////////////////////////
// internal wires related to register interface, and orcastra interface
//////////////////////////////////////////////////////////////////////////////

wire         pkt_add_swap_ri;
wire         pkt_loop_enb_ri;
wire         pkt_loop_clksel_ri;
wire         phy_reset_n_ri;
wire [15:0]  tx_sndpaustim_ri;
wire         tx_sndpausreq_ri;
wire         tx_fifoctrl_ri;
wire         rx_fifo_full_ri;
wire         tx_fifo_empty_ri;
wire         ignore_next_pkt_ri;
wire [8:0]   aff_thrhd;
wire [8:0]   afe_thrhd;

wire [7:0]   us_rdata;
wire         us_ack;
wire [7:0]   us_wdata;
wire         us_rdy;
wire         us_wr;
wire [17:0]  us_addr;
wire [1:0]   us_size;

wire         rxc_clk;
wire         txc_clk;

// from MAC to status reg bits in reg_intf
wire         rx_error_ri;
wire         rx_fifo_error_ri;
wire         tx_disfrm_ri;
wire         tx_fifo_full_ri;

wire         gbit_en_wire /*synthesis syn_keep=1 */;  // 1G enable - MAC clock select

// ------------------ signals related to the Orcastra Interface -------
wire         pc_clk_jtag;
wire         pc_clk_mux /*synthesis syn_keep=1 */;
wire         pc_datain_jtag;
wire         pc_datain_mux;
wire         pc_ready_jtag;
wire         pc_ready_mux;

assign phy_reset_n = phy_reset_n_ri; // this output is used only when user is using an eval board.
assign gbit_en = gbit_en_wire;


//////////////////////////////////////////////////////////////////////////////
// Internal wires related to GMII I/O
reg   [7:0]  rxd_pos;
reg   [3:0]  rxd_neg;
reg          rx_dv_pos;
reg          rx_dv_neg;
reg          rx_er_pos;
reg          rx_er_neg;
wire [7:0]   txd_pos;
wire [3:0]   txd_neg;
wire         tx_en_d;
wire         tx_er_d;

reg  [7:4]   txd_pos_x;
reg          tx_en_d_x;
reg          tx_er_d_x;
wire [3:0]   txd_int;
reg  [3:0]   txd_10_100;
reg          tx_en_10_100;
reg          tx_er_10_100;
reg  [7:0]   txd_1g;
reg          tx_en_1g;
reg          tx_er_1g;

// Internal wires related to clock synthesis
reg           tx_clk_div2;             // tx_clk divided by 2
reg           rx_clk_div2;             // rx_clk divided by 2
wire          txmac_clk_c /*synthesis syn_keep=1 */; // Internal txmac_clk
wire          rxmac_clk_c /*synthesis syn_keep=1 */; // Internal rxmac_clk
wire          gtx_clk_src; // for 1GBE
wire          txmac_clk_1g; //
wire          txmac_ref /*synthesis syn_keep=1 */;


//////////////////////////////////////////////////////////////////////////////
// Instantiate PLLs, DCS Muxes, and other buffers

    assign rx_write_e   = rx_write & rxmac_clk_en;
    assign tx_macread_e = tx_macread & txmac_clk_en;

// SGMII_TSMAC or GBE_MAC
assign rxmac_clk_c = rx_clk;

// This mux is added to allow a selection of the txmac_clk source
assign txmac_clk_c = pkt_loop_clksel_ri ? rx_clk : sys_clk;
assign gtx_clk_src = txmac_clk_c;
assign rxmac_clk = rxmac_clk_c;
assign txmac_clk = txmac_clk_c;


// GMII inputs RXD[3:0], RX_DV RX_ER are sampled on
// both clock edges of rxmac_clk_c
// These flip-flops must be placed close to the associated I/O pins.
// They are given a COMP name here and located in a specific component
// in the preference file.

always @(posedge rxmac_clk_c or negedge reset_n) begin
  if (~reset_n) begin
     rx_dv_pos    <= 1'b0;
     rx_er_pos    <= 1'b0;
     rxd_pos[7:0] <= 8'h00;
  end
  else begin
     rx_dv_pos    <= rx_dv;
     rx_er_pos    <= rx_er;
     rxd_pos[7:0] <= rxd[7:0];
  end
end

always @(negedge rxmac_clk_c or negedge reset_n) begin
  if (~reset_n) begin
     rx_dv_neg    <= 1'b0;
     rx_er_neg    <= 1'b0;
     rxd_neg[3:0] <= 4'h0;
  end
  else begin
     rx_dv_neg    <= rx_dv;
     rx_er_neg    <= rx_er;
     rxd_neg[3:0] <= rxd[3:0];
  end
end

// GBE_MAC OR SGMII_TSMAC
always @(posedge txmac_clk_c or negedge reset_n) begin
  if (~reset_n) begin
     txd_1g    <=  8'h00;
     tx_en_1g  <=  1'b0;
     tx_er_1g  <=  1'b0;
     end
  else begin
     txd_1g    <=  txd_pos;
     tx_en_1g  <=  tx_en_d;
     tx_er_1g  <=  tx_er_d;
     end
end

assign txd   = txd_1g;
assign tx_en = tx_en_1g;
assign tx_er = tx_er_1g;

//Note: User may need to invert clock to adjust timing
assign gtx_clk = gtx_clk_src;

assign pc_datain_mux = (jtag_parallel) ? pc_datain_jtag : pc_datain;
assign pc_ready_mux  = (jtag_parallel) ? pc_ready_jtag  : pc_ready;
assign pc_clk_mux    = (jtag_parallel) ? pc_clk_jtag    : pc_clk;

////////////////////////////////////////////////////////////////////////////
// Instantiate modules
ts_mac_core_only_top U1_ts_mac_core (
    // clock and reset
    .hclk(hclk),
    .txmac_clk(txmac_clk_c),
    .rxmac_clk(rxmac_clk_c),
    .reset_n(reset_n),
    .txmac_clk_en(txmac_clk_en),
    .rxmac_clk_en(rxmac_clk_en),

    // Input signals to the GMII
    .rxd(rxd_pos),
    .rx_dv(rx_dv_pos),
    .rx_er(rx_er_pos),
    .col(col),
    .crs(crs),

    // Input signals to the CPU Interface
    .haddr(haddr),
    .hdatain(hdatain),
    .hcs_n(hcs_n),
    .hwrite_n(hwrite_n),
    .hread_n(hread_n),

    // Input signals to the MII Management Interface

    // Input signals to the Tx MAC FIFO Interface
    .tx_fifodata(tx_fifodata),
    .tx_fifoavail(tx_fifoavail),
    .tx_fifoeof(tx_fifoeof),
    .tx_fifoempty(tx_fifoempty),
    .tx_sndpaustim(tx_sndpaustim),
    .tx_sndpausreq(tx_sndpausreq),
    .tx_fifoctrl(tx_fifoctrl),

    // Input signals to the Rx MAC FIFO Interface
    .rx_fifo_full(rx_fifo_full),
    .ignore_pkt(ignore_pkt),

    // Output signals from the GMII
    .txd(txd_pos),
    .tx_en(tx_en_d),
    .tx_er(tx_er_d),

    // Output signals from the CPU Interface
    .hdataout(hdataout),
    .hdataout_en_n(hdataout_en_n),
    .hready_n(hready_n),
    .cpu_if_gbit_en(gbit_en_wire),

    // Output signals from the MII Management Interface

    // Output signals from the Tx MAC FIFO Interface
    .tx_macread(tx_macread),
    .tx_discfrm(tx_discfrm),
    .tx_staten(tx_staten),
    .tx_statvec(tx_statvec),
    .tx_done(tx_done),

    // Output signals from the Rx MAC FIFO Interface
    .rx_fifo_error(rx_fifo_error),
    .rx_stat_vector(rx_stat_vector),
    .rx_dbout(rx_dbout),
    .rx_write(rx_write),
    .rx_stat_en(rx_stat_en),
    .rx_eof(rx_eof),
    .rx_error(rx_error)
);


tst_logic #(.pdevice_family(pdevice_family))
    u1_tst_logic (
    // -------
    // inputs
    // -------
    // Clock and Reset
    .reset_n                (reset_n),
    .txmac_clk              (txmac_clk_c),
    .rxmac_clk              (rxmac_clk_c),
    // Clock enables
    .txmac_clk_en           (txmac_clk_en),
    .rxmac_clk_en           (rxmac_clk_en),
    // from tsmac core
    .rx_write               (rx_write_e),
    .tx_macread             (tx_macread_e),
    .rx_dbout               (rx_dbout),
    .rx_eof                 (rx_eof),
    .rx_error               (rx_error),
    .rx_fifo_error          (rx_fifo_error),
    .tx_done                (tx_done),
    .tx_disfrm              (tx_discfrm),
    // from reg_intf
    .pkt_add_swap_ri        (pkt_add_swap_ri),
    .pkt_loop_enb_ri        (pkt_loop_enb_ri),
    .tx_sndpaustim_ri       (tx_sndpaustim_ri),
    .tx_sndpausreq_ri       (tx_sndpausreq_ri),
    .tx_fifoctrl_ri         (tx_fifoctrl_ri),
    .rx_fifo_full_ri        (rx_fifo_full_ri),
    .tx_fifo_empty_ri       (tx_fifo_empty_ri),
    .ignore_next_pkt_ri     (ignore_next_pkt_ri),
    .aff_thrhd              (aff_thrhd[8:0]),
    .afe_thrhd              (afe_thrhd[8:0]),
    // -------
    // outputs
    // -------
    // to tsmac core
    .tx_fifodata            (tx_fifodata),
    .tx_fifoeof             (tx_fifoeof),
    .tx_fifoavail           (tx_fifoavail),
    .tx_fifoempty           (tx_fifoempty),
    .tx_sndpaustim          (tx_sndpaustim),
    .tx_sndpausreq          (tx_sndpausreq),
    .tx_fifoctrl            (tx_fifoctrl),
    .rx_fifo_full           (rx_fifo_full),
    .ignore_next_pkt        (ignore_pkt),
    // to reg_intf
    .rxc_clk 		    (rxc_clk),
    .txc_clk 		    (txc_clk),
    .rx_error_ri            (rx_error_ri),
    .rx_fifo_error_ri       (rx_fifo_error_ri),
    .tx_disfrm_ri           (tx_disfrm_ri),
    .tx_fifo_full_ri        (tx_fifo_full_ri)
);

orcastra orcastra (
    .reset_n (reset_n),
    .hclk (hclk),
    .pc_clk (pc_clk_mux),
    .pc_datain (pc_datain_mux),
    .pc_ready (pc_ready_mux),
    .hdataout (hdataout),
    .hready_n (hready_n),
    .us_rdata (us_rdata),
    .us_ack (us_ack),
    .us_wdata (us_wdata),
    .us_rdy (us_rdy),
    .us_wr (us_wr),
    .us_addr (us_addr),
    .us_size (us_size),
    .hdatain (hdatain),
    .hcs_n (hcs_n),
    .hread_n (hread_n),
    .hwrite_n (hwrite_n),
    .haddr (haddr),
    .pc_dataout (pc_dataout),
    .pc_error (pc_error),
    .pc_retry (pc_retry),
    .pc_ack (pc_ack)
);

reg_intf reg_intf (
    .reset_n (reset_n),
    .hclk (hclk),
    .rxc_clk (rxc_clk),
    .txc_clk (txc_clk),
    .us_wdata (us_wdata),
    .us_rdy (us_rdy),
    .us_wr (us_wr),
    .us_addr (us_addr),
    .us_size (us_size),
    .rx_error_ri (rx_error_ri),
    .rx_fifo_error_ri (rx_fifo_error_ri),
    .tx_disfrm_ri (tx_disfrm_ri),
    .tx_fifo_full_ri (tx_fifo_full_ri),
    .rx_stat_vec (rx_stat_vector[31:0]),
    .rx_stat_en (rx_stat_en),
    .tx_stat_vec (tx_statvec[30:0]),
    .tx_stat_en (tx_staten),
    .pkt_add_swap_ri (pkt_add_swap_ri),
    .pkt_loop_enb_ri (pkt_loop_enb_ri),
    .pkt_loop_clksel_ri (pkt_loop_clksel_ri),
    .phy_reset_n_ri (phy_reset_n_ri),
    .tx_sndpaustim_ri (tx_sndpaustim_ri),
    .tx_sndpausreq_ri (tx_sndpausreq_ri),
    .tx_fifoctrl_ri (tx_fifoctrl_ri),
    .rx_fifo_full_ri (rx_fifo_full_ri),
    .tx_fifo_empty_ri (tx_fifo_empty_ri),
    .ignore_next_pkt_ri (ignore_next_pkt_ri),
    .aff_thrhd (aff_thrhd[8:0]),
    .afe_thrhd (afe_thrhd[8:0]),
    .us_err (), //no_connect
    .us_irq (), //no_connect
    .us_ack (us_ack),
    .us_rdata (us_rdata)
);




JTAG_ECP3 JTAG_ECP3
    (
    .grst_ni     (reset_n),
    .tck         (tck),
    .tms         (tms),
    .tdi         (tdi),
    .tdo         (tdo),
    .PC_Clk      (pc_clk_jtag),
    .PC_Data_In	 (pc_datain_jtag),
    .PC_Ready    (pc_ready_jtag),
    .PC_Reset    (),
    .Cnt         (),
    .PC_Data_Out (pc_dataout),
    .PC_Ack	 (pc_ack),
    .PC_Error	 (pc_error)
);



endmodule
