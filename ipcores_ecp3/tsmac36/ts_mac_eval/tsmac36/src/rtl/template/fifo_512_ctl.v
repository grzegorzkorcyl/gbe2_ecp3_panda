// ===========================================================================
// Verilog module generated by IPexpress
// Filename: fifo_512_ctl.v  
// Copyright 2012 (c) Lattice Semiconductor Corporation. All rights reserved.
// ===========================================================================

module fifo_512_ctl (
// INPUTS
     ckw,	// write clock for fifo
     ckw_en,	// write clock enable for fifo
     csw,	// write select for fifo
     rst_wr,	// fifo write clock domain reset active low
     rst_rd,	// fifo read clock domain reset active low
     ckr,	// read clock for fifo
     ckr_en,	// read clock enable for fifo
     csr,	// read select for fifo
     aff_thrhd,	// 9 bit almost full flag threshold value
     afe_thrhd,	// 9 bit almost empty flag threshold value

// OUTPUTS     
     wr_adr,	// FIFO write address to ram
     rd_adr,	// FIFO read address to ram
     ef,	// empty flag
     aff,	// almost full flag 
     afe,	// almost empty flag 
     ff,	// full flag
     wr_en,	// ram write enable
     rd_en,	// read enable
     ram_rd_en	// ram read enable to the ram
   );

parameter SYNC_MODE = "SYNC";
parameter RAM_MODE = "REG";

input ckw;		// write clock for fifo
input ckw_en;		// write clock enable for fifo
input csw;		// write select for fifo
input rst_wr;		// fifo write clock domain reset active low
input rst_rd;		// fifo read clock domain reset active low
input ckr;		// read clock for fifo
input ckr_en;		// resd clock enable for fifo
input csr;		// read select for fifo
input  [8:0] aff_thrhd;	// 9 bit almost full flag threshold value
input  [8:0] afe_thrhd;	// 9 bit almost empty flag threshold value

output [8:0] wr_adr;
output [8:0] rd_adr;
output wr_en, rd_en, ram_rd_en;
output ef, ff, aff, afe;	

// DECLARATIONS
wire wr_en;
wire rd_en;
wire ram_rd_en;
wire	[9:0] sync_wcnt, sync_rcnt;
wire	[9:0] async_wcnt, async_rcnt;
wire	[9:0] wcnt;
wire	[9:0] rcnt;
wire	[8:0] wr_adr, rd_adr;

reg	[9:0] wr_addr;
reg	[9:0] rd_addr;
reg	[9:0] rd_addr_reg;
reg	ef, ff, aff, afe;
wire	[8:0] rd_addr_temp;

// select the old address during fifo empty. This application is
// used for the special ECP ram model with read clock enable input 
assign	rd_addr_temp[8:0] = (ef) ? rd_addr_reg[8:0] : rd_addr[8:0];


// ASSIGN
assign	wr_en = csw & (~ff);
assign	rd_en = csr & (~ef);
assign	ram_rd_en = csr | ef;
assign	wr_adr[8:0] = wr_addr[8:0];

// select the input read address with register mode or without register mode
//assign	rd_adr[8:0] = (RAM_MODE == "REG") ? rd_addr[8:0] : rd_addr_reg[8:0];
assign	rd_adr[8:0] = (RAM_MODE == "REG") ? rd_addr_temp[8:0] : rd_addr_reg[8:0];

// select the SYNC mode or ASYNC mode
assign  wcnt[9:0] = (SYNC_MODE == "SYNC")? sync_wcnt[9:0] : async_wcnt[9:0];	
assign  rcnt[9:0] = (SYNC_MODE == "SYNC")? sync_rcnt[9:0] : async_rcnt[9:0];	

assign	sync_wcnt[9:0] = {rd_addr_reg[9]^wr_addr[9], wr_addr[8:0]} - rd_addr_reg[8:0];
assign	sync_rcnt[9:0] = {wr_addr[9]^rd_addr_reg[9], wr_addr[8:0]} - rd_addr_reg[8:0];
	
// DECLARATIONS
reg	[9:0] wr_addr_gc;
reg	[9:0] wr2_addr;

// wire	[9:0] wr1_addr;
// assign wr1_addr[9:0] = wr_addr[9:0]+1;
// wr2_addr is the same logic function as wr1_addr 
// use wr2_addr replace wr1_addr for improve timing.
//assign wr1_addr[9:0] = wr_addr[9:0]+1 after wr_addr
// increased by 1 and wr2_addr[9:0] = wr_addr[9:0]+ 2
// at the same time wr_addr increase by 1;


// generate write address
always @(posedge ckw or negedge rst_wr) begin
    if (~rst_wr) begin
	 wr_addr[9:0] <= 10'd0;
	 wr_addr_gc[9:0] <= 10'd0;
	 wr2_addr[9:0] <= 10'd0;
    end // if
    else begin
	if(ckw_en == 1) begin
	if(wr_en == 1) begin
	 	wr_addr[9:0] <= wr_addr[9:0] + 1;
	 	wr2_addr[9:0] <= wr_addr[9:0] + 2;
	 	wr_addr_gc[0] <= wr2_addr[0]^wr2_addr[1];
	 	wr_addr_gc[1] <= wr2_addr[1]^wr2_addr[2];
	 	wr_addr_gc[2] <= wr2_addr[2]^wr2_addr[3];
	 	wr_addr_gc[3] <= wr2_addr[3]^wr2_addr[4];
	 	wr_addr_gc[4] <= wr2_addr[4]^wr2_addr[5];
	 	wr_addr_gc[5] <= wr2_addr[5]^wr2_addr[6];
	 	wr_addr_gc[6] <= wr2_addr[6]^wr2_addr[7];
	 	wr_addr_gc[7] <= wr2_addr[7]^wr2_addr[8];
	 	wr_addr_gc[8] <= wr2_addr[8]^wr2_addr[9];
	 	wr_addr_gc[9] <= wr2_addr[9];
    	end // if
    	end // if
    end // else
end // always
	
// DECLARATIONS
reg	[9:0] rd_addr_gc;
reg	[9:0] rd2_addr;

// wire	[9:0] rd1_addr;
// assign rd1_addr[9:0] = rd_addr[9:0]+1;
// rd2_addr is the same logic function as rd1_addr 
// use rd2_addr replace rd1_addr for improve timing.
// assign rd1_addr[9:0] = rd_addr[9:0]+1 after rd_addr
// increased by 1 and rd2_addr[9:0] = rd_addr[9:0]+ 2
// at the same time rd_addr increase by 1;

// generate read address 
always @(posedge ckr or negedge rst_rd) begin
    if (~rst_rd) begin
	 rd_addr[9:0] <= 10'd1;
	 rd_addr_reg[9:0] <= 10'd0;
	 rd_addr_gc[9:0] <= 10'd0;
	 rd2_addr[9:0] <= 10'd0;
    end // if
    else begin
	if(ckr_en == 1) begin
	if(rd_en == 1) begin
	 	rd_addr[9:0] <= rd_addr[9:0] + 1;
	 	rd_addr_reg[9:0] <= rd_addr[9:0];
	 	rd2_addr[9:0] <= rd_addr_reg[9:0] + 2;
	 	rd_addr_gc[0] <= rd2_addr[0]^rd2_addr[1];
	 	rd_addr_gc[1] <= rd2_addr[1]^rd2_addr[2];
	 	rd_addr_gc[2] <= rd2_addr[2]^rd2_addr[3];
	 	rd_addr_gc[3] <= rd2_addr[3]^rd2_addr[4];
	 	rd_addr_gc[4] <= rd2_addr[4]^rd2_addr[5];
	 	rd_addr_gc[5] <= rd2_addr[5]^rd2_addr[6];
	 	rd_addr_gc[6] <= rd2_addr[6]^rd2_addr[7];
	 	rd_addr_gc[7] <= rd2_addr[7]^rd2_addr[8];
	 	rd_addr_gc[8] <= rd2_addr[8]^rd2_addr[9];
	 	rd_addr_gc[9] <= rd2_addr[9];
    	end // if
    	end // if
    end // else
end // always

reg	[9:0] rd_addr_gcf;

// convert read address to write clock domain
always @(posedge ckw or negedge rst_wr) begin
    if (~rst_wr) begin
	 rd_addr_gcf[9:0] <= 10'd0;
    end // if
    else begin
	if(ckw_en == 1) begin
	 rd_addr_gcf[9:0] <= rd_addr_gc[9:0];
    	end // if
    end // else
end // always

reg	[9:0] wr_addr_gcf;

// convert write address to read clock domain
always @(posedge ckr or negedge rst_rd) begin
    if (~rst_rd) begin
	 wr_addr_gcf[9:0] <= 10'd0;
    end // if
    else begin
	if(ckr_en == 1) begin
	 wr_addr_gcf[9:0] <= wr_addr_gc[9:0];
    	end // if
    end // else
end // always

// convert write address gray code back to binary code

/*
wire	[9:0] wr_addr_bin_ckr;
assign	wr_addr_bin_ckr[0] = wr_addr_gcf[0]^wr_addr_gcf[1]^wr_addr_gcf[2]
	^wr_addr_gcf[3]^wr_addr_gcf[4]^wr_addr_gcf[5]^wr_addr_gcf[6]
	^wr_addr_gcf[7]^wr_addr_gcf[8]^wr_addr_gcf[9];
assign	wr_addr_bin_ckr[1] = wr_addr_gcf[1]^wr_addr_gcf[2]^wr_addr_gcf[3]
	^wr_addr_gcf[4]^wr_addr_gcf[5]^wr_addr_gcf[6]
	^wr_addr_gcf[7]^wr_addr_gcf[8]^wr_addr_gcf[9];
assign	wr_addr_bin_ckr[2] = wr_addr_gcf[2]^wr_addr_gcf[3]^wr_addr_gcf[4]
	^wr_addr_gcf[5]^wr_addr_gcf[6]^wr_addr_gcf[7]
	^wr_addr_gcf[8]^wr_addr_gcf[9];
assign	wr_addr_bin_ckr[3] = wr_addr_gcf[3]^wr_addr_gcf[4]^wr_addr_gcf[5]
	^wr_addr_gcf[6]^wr_addr_gcf[7]^wr_addr_gcf[8]^wr_addr_gcf[9];
assign	wr_addr_bin_ckr[4] = wr_addr_gcf[4]^wr_addr_gcf[5]^wr_addr_gcf[6]
	^wr_addr_gcf[7]^wr_addr_gcf[8]^wr_addr_gcf[9];
assign	wr_addr_bin_ckr[5] = wr_addr_gcf[5]^wr_addr_gcf[6]
	^wr_addr_gcf[7]^wr_addr_gcf[8]^wr_addr_gcf[9];
assign	wr_addr_bin_ckr[6] = wr_addr_gcf[6]^wr_addr_gcf[7]
        ^wr_addr_gcf[8]^wr_addr_gcf[9];
assign	wr_addr_bin_ckr[7] = wr_addr_gcf[7]^wr_addr_gcf[8]^wr_addr_gcf[9];
assign	wr_addr_bin_ckr[8] = wr_addr_gcf[8]^wr_addr_gcf[9];
assign	wr_addr_bin_ckr[9] = wr_addr_gcf[9];
*/

// for timing reason  convert wire to register 
// the design will add one clock delay for the write counter 
// before compare to the read counter

reg	[9:0] wr_addr_bin_ckr;
always @(posedge ckr or negedge rst_rd) begin
    if (~rst_rd) begin
	 wr_addr_bin_ckr[9:0] <= 10'd0;
    end // if
    else begin
	if(ckr_en == 1) begin
 	wr_addr_bin_ckr[0] <= wr_addr_gcf[0]^wr_addr_gcf[1]^wr_addr_gcf[2]
	^wr_addr_gcf[3]^wr_addr_gcf[4]^wr_addr_gcf[5]^wr_addr_gcf[6]
	^wr_addr_gcf[7]^wr_addr_gcf[8]^wr_addr_gcf[9];
 	wr_addr_bin_ckr[1] <= wr_addr_gcf[1]^wr_addr_gcf[2]^wr_addr_gcf[3]
	^wr_addr_gcf[4]^wr_addr_gcf[5]^wr_addr_gcf[6]
	^wr_addr_gcf[7]^wr_addr_gcf[8]^wr_addr_gcf[9];
 	wr_addr_bin_ckr[2] <= wr_addr_gcf[2]^wr_addr_gcf[3]^wr_addr_gcf[4]
	^wr_addr_gcf[5]^wr_addr_gcf[6]^wr_addr_gcf[7]^wr_addr_gcf[8]^wr_addr_gcf[9];
 	wr_addr_bin_ckr[3] <= wr_addr_gcf[3]^wr_addr_gcf[4]^wr_addr_gcf[5]
	^wr_addr_gcf[6]^wr_addr_gcf[7]^wr_addr_gcf[8]^wr_addr_gcf[9];
 	wr_addr_bin_ckr[4] <= wr_addr_gcf[4]^wr_addr_gcf[5]^wr_addr_gcf[6]
	^wr_addr_gcf[7]^wr_addr_gcf[8]^wr_addr_gcf[9];
 	wr_addr_bin_ckr[5] <= wr_addr_gcf[5]^wr_addr_gcf[6]
	^wr_addr_gcf[7]^wr_addr_gcf[8]^wr_addr_gcf[9];
 	wr_addr_bin_ckr[6] <= wr_addr_gcf[6]^wr_addr_gcf[7]
	^wr_addr_gcf[8]^wr_addr_gcf[9];
 	wr_addr_bin_ckr[7] <= wr_addr_gcf[7]^wr_addr_gcf[8]^wr_addr_gcf[9];
 	wr_addr_bin_ckr[8] <= wr_addr_gcf[8]^wr_addr_gcf[9];
 	wr_addr_bin_ckr[9] <= wr_addr_gcf[9];
    	end //if
    end // else
end // always

assign	async_rcnt[9:0] = {wr_addr_bin_ckr[9]^rd_addr_reg[9], wr_addr_bin_ckr[8:0]} 
			- rd_addr_reg[8:0];

/*
wire	[9:0] rd_addr_bin_ckw;
assign	rd_addr_bin_ckw[0] = rd_addr_gcf[0]^rd_addr_gcf[1]^rd_addr_gcf[2]
	^rd_addr_gcf[3]^rd_addr_gcf[4]^rd_addr_gcf[5]^rd_addr_gcf[6]
	^rd_addr_gcf[7]^rd_addr_gcf[8]^rd_addr_gcf[9];
assign	rd_addr_bin_ckw[1] = rd_addr_gcf[1]^rd_addr_gcf[2]^rd_addr_gcf[3]
	^rd_addr_gcf[4]^rd_addr_gcf[5]^rd_addr_gcf[6]
	^rd_addr_gcf[7]^rd_addr_gcf[8]^rd_addr_gcf[9];
assign	rd_addr_bin_ckw[2] = rd_addr_gcf[2]^rd_addr_gcf[3]^rd_addr_gcf[4]
	^rd_addr_gcf[5]^rd_addr_gcf[6]^rd_addr_gcf[7]
	^rd_addr_gcf[8]^rd_addr_gcf[9];
assign	rd_addr_bin_ckw[3] = rd_addr_gcf[3]^rd_addr_gcf[4]^rd_addr_gcf[5]
	^rd_addr_gcf[6]^rd_addr_gcf[7]^rd_addr_gcf[8]^rd_addr_gcf[9];
assign	rd_addr_bin_ckw[4] = rd_addr_gcf[4]^rd_addr_gcf[5]^rd_addr_gcf[6]
	^rd_addr_gcf[7]^rd_addr_gcf[8]^rd_addr_gcf[9];
assign	rd_addr_bin_ckw[5] = rd_addr_gcf[5]^rd_addr_gcf[6]
	^rd_addr_gcf[7]^rd_addr_gcf[8]^rd_addr_gcf[9];
assign	rd_addr_bin_ckw[6] = rd_addr_gcf[6]^rd_addr_gcf[7]
        ^rd_addr_gcf[8]^rd_addr_gcf[9];
assign	rd_addr_bin_ckw[7] = rd_addr_gcf[7]^rd_addr_gcf[8]^rd_addr_gcf[9];
assign	rd_addr_bin_ckw[8] = rd_addr_gcf[8]^rd_addr_gcf[9];
assign	rd_addr_bin_ckw[9] = rd_addr_gcf[9];
*/

// for timing reason  convert wire to register 
// the design will add one clock delay for the read counter 
// before compare to the write counter

reg	[9:0] rd_addr_bin_ckw;
always @(posedge ckw or negedge rst_wr) begin
    if (~rst_wr) begin
	 rd_addr_bin_ckw[9:0] <= 10'd0;
    end // if
    else begin
	if(ckw_en == 1) begin
	rd_addr_bin_ckw[0] <= rd_addr_gcf[0]^rd_addr_gcf[1]^rd_addr_gcf[2]
	^rd_addr_gcf[3]^rd_addr_gcf[4]^rd_addr_gcf[5]^rd_addr_gcf[6]
	^rd_addr_gcf[7]^rd_addr_gcf[8]^rd_addr_gcf[9];
	rd_addr_bin_ckw[1] <= rd_addr_gcf[1]^rd_addr_gcf[2]^rd_addr_gcf[3]
	^rd_addr_gcf[4]^rd_addr_gcf[5]^rd_addr_gcf[6]
	^rd_addr_gcf[7]^rd_addr_gcf[8]^rd_addr_gcf[9];
	rd_addr_bin_ckw[2] <= rd_addr_gcf[2]^rd_addr_gcf[3]^rd_addr_gcf[4]
	^rd_addr_gcf[5]^rd_addr_gcf[6]^rd_addr_gcf[7]
	^rd_addr_gcf[8]^rd_addr_gcf[9];
	rd_addr_bin_ckw[3] <= rd_addr_gcf[3]^rd_addr_gcf[4]^rd_addr_gcf[5]
	^rd_addr_gcf[6]^rd_addr_gcf[7]^rd_addr_gcf[8]^rd_addr_gcf[9];
	rd_addr_bin_ckw[4] <= rd_addr_gcf[4]^rd_addr_gcf[5]^rd_addr_gcf[6]
	^rd_addr_gcf[7]^rd_addr_gcf[8]^rd_addr_gcf[9];
	rd_addr_bin_ckw[5] <= rd_addr_gcf[5]^rd_addr_gcf[6]
	^rd_addr_gcf[7]^rd_addr_gcf[8]^rd_addr_gcf[9];
	rd_addr_bin_ckw[6] <= rd_addr_gcf[6]^rd_addr_gcf[7]
	^rd_addr_gcf[8]^rd_addr_gcf[9];
	rd_addr_bin_ckw[7] <= rd_addr_gcf[7]^rd_addr_gcf[8]^rd_addr_gcf[9];
	rd_addr_bin_ckw[8] <= rd_addr_gcf[8]^rd_addr_gcf[9];
	rd_addr_bin_ckw[9] <= rd_addr_gcf[9];
    	end // if
    end // else
end // always

assign	async_wcnt[9:0] = {rd_addr_bin_ckw[9]^wr_addr[9], wr_addr[8:0]} - rd_addr_bin_ckw[8:0];

//  detect the fifo full
always @(posedge ckw or negedge rst_wr) begin
    if (~rst_wr) begin
	 ff <= 1'b0;
	 aff <= 1'b0;
    end // if
    else begin
	if(ckw_en == 1) begin
	if(wcnt[9:0] >= 511 | ((wcnt[9:0] == 510) && (wr_en == 1))) begin
		ff <= 1'b1;
    	end // if
	else begin
		ff <= 1'b0;
    	end // if

        // this extra bit is used  to take care of SPYGLASS warning messages
	if(wcnt[9:0] >= {1'b0,aff_thrhd[8:0]}) begin
		aff <= 1'b1;
    	end // if
    	else begin
		aff <= 1'b0;
    	end // else
    	end // if
    end // else
end // always

//  detect the fifo empty
always @(posedge ckr or negedge rst_rd) begin
    if (~rst_rd) begin
	 ef <= 1'b1;
	 afe <= 1'b1;
    end // if
    else begin
	if(ckr_en == 1) begin
	if((rcnt[9:0] == 0) || ((rcnt[9:0] == 1) && (rd_en == 1))) begin
		ef <= 1'b1;
    	end // if
    	else begin
		ef <= 1'b0;
    	end // else

        // this extra bit is used  to take care of SPYGLASS warning messages
	if(rcnt[9:0] <= {1'b0,afe_thrhd[8:0]}) begin
		afe <= 1'b1;
    	end // if
    	else begin
		afe <= 1'b0;
    	end // else
    	end // if
    end // else
end // always
endmodule    // end of rfifo_ctl
