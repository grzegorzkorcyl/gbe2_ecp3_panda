// ===========================================================================
// Verilog module generated by IPexpress
// Filename: orcastra.v  
// Copyright 2005 (c) Lattice Semiconductor Corporation. All rights reserved.
// ===========================================================================



//`timescale 1ns/100ps


module orcastra (
        //----------------------
        // inputs to orcastra_intf
        //----------------------
	//
        //************
        // resets 
        //************
        reset_n,
        //************
        // clocks 
        //************
        hclk,
        pc_clk,
        //************************
        // from pc parallel port 
        //************************
        pc_datain,
        pc_ready,
	//****************
	// from host bus 
	//****************
	hdataout,
	hready_n,
        //*****************
        //from reg_intf   
        //*****************
	us_rdata,
	us_ack,
        //*****************
        //----------------------------
        // outputs from orcastra_intf 
        //----------------------------
	//
        //*****************
        //to reg_intf 
        //*****************
	us_wdata,
	us_rdy,
	us_wr,
	us_addr,
	us_size,
        //********************
        // to MAC Host bus intf 
        //********************
        hdatain,
        hcs_n,
        hread_n,
        hwrite_n,
        haddr,
        //********************
        // to pc parallel port 
        //********************
        pc_dataout,
        pc_error,
        pc_retry,
        pc_ack );


//---------
// INPUTS
//---------
//************
// resets 
//************
input reset_n;
//************
// clocks 
//************
input hclk;
input pc_clk;
//************************
// from pc parallel port 
//************************
input pc_datain;
input pc_ready;
//***************
// from host bus 
//***************
input [7:0] hdataout;
input hready_n;
//*****************
//from reg_intf   
//*****************
input [7:0] us_rdata;
input us_ack;
//*****************
//---------
// OUTPUTS
//---------
//*****************
//to reg_intf 
//*****************
output [7:0] us_wdata;
output us_rdy;
output us_wr;
output [17:0] us_addr;
output [1:0] us_size;
//********************
// to MAC Host bus intf 
//********************
output [7:0] hdatain;
output hcs_n;
output hread_n;
output hwrite_n;
output [7:0] haddr;
//********************
// to pc parallel port 
//********************
output pc_dataout;
output pc_error;
output pc_retry;
output pc_ack; 


//-------------------
// SIGNAL assignments
//-------------------
wire [7:0] us_wdata;
reg us_rdy;
reg us_wr;
wire [17:0] us_addr;
wire [1:0] us_size;
wire [7:0] hdatain;
reg hcs_n;
reg hread_n;
reg hwrite_n;
wire [7:0] haddr;
reg pc_dataout;
reg pc_error;
wire pc_retry;
reg pc_ack; 

wire orc_ack;
reg [7:0] sreg_do;
reg [25:0] sreg_di;
reg [25:0] reg_di;
reg [2:0] rdwr_st;
reg pc_ready_1d;
reg pc_ready_2d;
reg pc_ready_3d;
reg orc_ack_1d;
reg orc_ack_2d;
reg orc_ack_3d;
reg pc_rdy_pulse;
wire [7:0] mux_dout;
wire tstl_regs;

reg gate_clk_ctl1;
reg gate_clk_ctl2;
wire gate_clk;
reg [8:0] timeout_cnt;
wire timeout;

// PARAMETERS

parameter [1:0]
	SIZE = 2'b00;

parameter [2:0]
	IDLE    = 3'b000,	// IDLE State
	READ    = 3'b001,	// READ State
	WRITE   = 3'b010,	// WRITE State
	WAIT1   = 3'b011,	// WAIT1 State
	WAIT2   = 3'b100;	// WAIT2 State

        assign  gate_clk_ctl = gate_clk_ctl1 & gate_clk_ctl2;
        assign  gate_clk = gate_clk_ctl ? hclk:pc_clk;
        assign  mux_dout = tstl_regs ? us_rdata:hdataout;

        assign  tstl_regs = (reg_di[17:6] == 12'h200) ? 1'b1:1'b0;

        assign  us_size[1:0] = SIZE;
        assign  pc_retry = 1'b0;
        assign  timeout = (timeout_cnt[8:0] == 9'h000) ? 1'b1:1'b0;
        assign  orc_ack = (!hready_n | us_ack);


        //-------------------------------------------------------------------
        // Pipeline pc_ready and orc_ack and
        // Edge detector for pc_ready signal - generates a one clk wide
        // "pc_rdy_pulse" on a L->H transition of pc_ready
        //-------------------------------------------------------------------
        always @(posedge hclk or negedge reset_n) begin
          if (~reset_n) begin
                pc_ready_1d <= #1 1'b0;
                pc_ready_2d <= #1 1'b0;
                pc_ready_3d <= #1 1'b0;
                orc_ack_1d <= #1 1'b0;
                orc_ack_2d <= #1 1'b0;
                orc_ack_3d <= #1 1'b0;
                pc_rdy_pulse <= #1 1'b0;
          end
          else begin
                pc_ready_1d <= #1 pc_ready;
                pc_ready_2d <= #1 pc_ready_1d;
                pc_ready_3d <= #1 pc_ready_2d;
                orc_ack_1d <= #1 orc_ack;
                orc_ack_2d <= #1 orc_ack_1d;
                orc_ack_3d <= #1 orc_ack_2d;
                pc_rdy_pulse <= (~pc_ready_3d & pc_ready_2d);
          end // else
        end // always


	// ---------------------------------------------------------------------------
        // gclk gate control2 on falling edge to prevent runt 
	// ---------------------------------------------------------------------------
        always @(negedge hclk or negedge reset_n) begin
          if (~reset_n) begin
                gate_clk_ctl2 <= #1 1'b1;
          end
          else begin
                gate_clk_ctl2 <= #1 !orc_ack_1d;
          end
        end // always

	// ---------------------------------------------------------------------------
        // shift reg - sreg_di - shift data and address in
	// ---------------------------------------------------------------------------
        always @(negedge pc_clk or negedge reset_n) begin
          if (~reset_n) begin
            sreg_di[25:0] <= #1 26'h0000000;
          end
          else begin
             sreg_di <= sreg_di << 1;  // Shift Left
             sreg_di[0] <= pc_datain;
          end
        end // always

        //-------------------------------------------------------------------
	// Latch data and address into internal reg clocked by hclk
        //-------------------------------------------------------------------
        always @(posedge hclk or negedge reset_n) begin
          if (~reset_n) begin
                reg_di[25:0] <= #1 26'h0000000;
          end
          else begin
		if (pc_rdy_pulse) begin
                  reg_di[25:0] <= #1 sreg_di[25:0];
                end
          end // else
        end // always

        assign us_wdata[7] = reg_di[18];
        assign us_wdata[6] = reg_di[19];
        assign us_wdata[5] = reg_di[20];
        assign us_wdata[4] = reg_di[21];
        assign us_wdata[3] = reg_di[22];
        assign us_wdata[2] = reg_di[23];
        assign us_wdata[1] = reg_di[24];
        assign us_wdata[0] = reg_di[25];

        assign hdatain[7]  = reg_di[18];
        assign hdatain[6]  = reg_di[19];
        assign hdatain[5]  = reg_di[20];
        assign hdatain[4]  = reg_di[21];
        assign hdatain[3]  = reg_di[22];
        assign hdatain[2]  = reg_di[23];
        assign hdatain[1]  = reg_di[24];
        assign hdatain[0]  = reg_di[25];

        assign haddr[7:0]    = reg_di[7:0];
        assign us_addr[17:0] = reg_di[17:0];


	// ---------------------------------------------------------------------------
	// Latch output read data to 8 bit shift reg - sreg_do  
	// ---------------------------------------------------------------------------
        always @(negedge gate_clk or negedge reset_n) begin
          if (~reset_n) begin
            sreg_do[7:0] <= #1 8'h00;
	    pc_dataout <= #1 1'b0;
          end
          else begin
	    if (orc_ack_1d) begin
	      sreg_do[7:0] <= mux_dout[7:0];
            end
            else begin
	      sreg_do <= sreg_do >> 1; // shift Left 
	      sreg_do[7] <= 1;
            end
          pc_dataout <= sreg_do[0];
          end
        end // always

	
	// ---------------------------------------------------------------------------


	// ---------------------------------------------------------------------------
	// Read/Write FSM 
	// ---------------------------------------------------------------------------

        always @(posedge hclk or negedge reset_n) begin
          if (~reset_n) begin
            rdwr_st <= #1 IDLE;
	    gate_clk_ctl1 <= #1 1'b0;
	    us_rdy <= #1 1'b0;
	    us_wr <= #1 1'b0;
            hcs_n <= #1 1'b1;
            hread_n <= #1 1'b1;
            hwrite_n <= #1 1'b1;
            pc_ack <= #1 1'b0;
            pc_error <= #1 1'b0;
            timeout_cnt <= #1 9'h1ff;
          end
          else begin
		// default values
	    	us_rdy <= #1 1'b0;

		case (rdwr_st)

			IDLE:
			     begin
	    			us_wr <= #1 1'b0;
            			hcs_n <= #1 1'b1;
            			hread_n <= #1 1'b1;
            			hwrite_n <= #1 1'b1;
	    			gate_clk_ctl1 <= #1 1'b0;
            			timeout_cnt <= #1 9'h1ff;
            			pc_ack <= #1 1'b0;
            			pc_error <= #1 1'b0;

	    			if (pc_rdy_pulse) begin
				   if (pc_datain == 1'b0) begin // Write
				     rdwr_st <= #1 WRITE;
			           end
				   else begin // read
				     rdwr_st <= #1 READ;
	    			     gate_clk_ctl1 <= #1 1'b1;
			           end
			        end
			     end
			READ:
			     begin
				if (tstl_regs) begin
	    			  us_rdy <= #1 1'b1;
	    			  us_wr <= #1 1'b0;
				end
				else begin
            			  hcs_n <= #1 1'b0;
            			  hread_n <= #1 1'b0;
            			  hwrite_n <= #1 1'b1;
				end

				rdwr_st <= #1 WAIT1;
			     end
			WRITE:
			     begin
				if (tstl_regs) begin
	    			  us_rdy <= #1 1'b1;
	    			  us_wr <= #1 1'b1;
				end
				else begin
            			  hcs_n <= #1 1'b0;
            			  hread_n <= #1 1'b1;
            			  hwrite_n <= #1 1'b0;
				end

				rdwr_st <= #1 WAIT1;
			     end
			WAIT1:
			     begin
            			// timeout_cnt <= #1 timeout_cnt - 1;
				// if (timeout) begin
            			//     pc_ack <= #1 1'b1;
            			//     pc_error <= #1 1'b1;
				//     rdwr_st <= #1 WAIT2;
				// end
				// else begin
				  if (orc_ack) begin
	    			    us_wr <= #1 1'b0;
            			    hcs_n <= #1 1'b1;
            			    hread_n <= #1 1'b1;
            			    hwrite_n <= #1 1'b1;
            			    pc_ack <= #1 1'b1;
				    rdwr_st <= #1 WAIT2;
				  end
				// end
			     end
			WAIT2:
			     begin
	    			gate_clk_ctl1 <= #1 1'b0;
				if (pc_ready_3d == 1'b0) begin
            			  pc_ack <= #1 1'b0;
            			  pc_error <= #1 1'b0;
				  rdwr_st <= #1 IDLE;
				end
			     end
			default:
			     begin
            			rdwr_st <= #1 IDLE;
	    			gate_clk_ctl1 <= #1 1'b0;
	    			us_rdy <= #1 1'b0;
	    			us_wr <= #1 1'b0;
            			hcs_n <= #1 1'b1;
            			hread_n <= #1 1'b1;
            			hwrite_n <= #1 1'b1;
            			pc_ack <= #1 1'b0;
            			pc_error <= #1 1'b0;
            			timeout_cnt <= #1 9'h1ff;
			     end
		endcase 
          end
        end // always 


endmodule // orcastra




